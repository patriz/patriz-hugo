+++
date          = "2019-08-10T13:14:00+09:00"
draft         = true
title         = "[번역] 고성능 Go Workshop"
tags          = ["Go", "Golang", "High Performance"]
categories    = ["Programming"]
slug          = "high-performance-go-workshop"
toc           = true
socialsharing = true
nocomment     = false
+++

## 개요

이 워크샵의 목표는 Go 애플리케이션에서 성능 문제를 진단하고 해결하는 데 필요한 도구를 제공하는 것입니다.

하루 동안 벤치마크를 작성하는 방법을 배우고, 작은 코드 조각을 프로파일링하는 등 작은 것부터 작업할 것입니다. 그런 다음 한걸음 나와 엑스큐션 트레이서, 가비지 콜렉터, 실행 중인 애플리케이션 추적에 대해 애기할게요. 오늘 나머지 시간은 질문할 수 있는 기회와 자신의 코드로 실험할 수 있는 기회가 될 것입니다.

> 이 프리젠테이션의 최신 버전은 다음 사이트에서 확인하세요:
> http://bit.ly/dotgo2019


## 일정

다음은 오늘의 개략적인 일정입니다.

|시작 |설명|
|-----|---|
|09:00|환영 인사 그리고 소개|
|09:30|벤치마킹|
|10:45|휴식 (15분)|
|11:00|성능 측정 그리고 프로파일링|
|12:00|점심 (90분) |
|13:30|컴파일러 최적화|
|14:30|엑스큐션 트레이서|
|15:30|휴식 (15분)|
|15:45|메모리 그리고 가비지 콜렉터|
|16:15|팁과 트릭|
|16:30|연습|
|16:45|최종 질문 및 결론|
|17:00|끝맺음|

## 환영인사

안녕하세요, 환영합니다 🎉

이 워크샵의 목표는 Go 애플리케이션에서 성능 문제를 진단하고 해결하는 데 필요한 도구를 제공하는 것입니다.

하루 동안 벤치마크를 작성하는 방법을 배우고, 작은 코드 조각을 프로파일링하는 등 작은 것부터 작업할 것입니다. 그런 다음 한걸음 나와 엑스큐션 트레이서, 가비지 콜렉터, 실행 중인 애플리케이션 추적에 대해 애기할게요. 오늘 나머지 시간은 질문할 수 있는 기회와 자신의 코드로 실험할 수 있는 기회가 될 것입니다.

### 강사
- Dave Cheney dave@cheney.net

## 라이센스 및 내용물

이 워크숍은 [데이비드 체니](https://twitter.com/davecheney)와 [프란체스코 캄포이](https://twitter.com/francesc)의 합작품이다.

이 프레젠테이션은 [Creative Commons At Attion-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-sa/4.0/) 라이선스에 따라 라이센스가 부여된다.

## 선행 조건 

오늘 필요한 몇 가지 소프트웨어를 다운로드해야 합니다.

### 워크샵 저장소

https://github.com/davecheney/high-performance-go-workshop에서 이 문서에 대한 소스와 및 코드 샘플을 다운로드하세요.

### 노트북, 전원 공급 장치 등
워크샵 자료의 타겟은 Go 1.12이다.

[Go 1.12 다운로드](https://golang.org/dl/)

> Go 1.13으로 이미 업그레이드했다면 좋습니다. 마이너 Go 릴리스 간에는  최적화 선택에 항상 약간의 변경 사항이 있는데, 진행하면서 언급하겠습니다. 

### Graphviz

pprof 섹션에서 그래피즈 도구 모음과 함께 제공되는 도트 프로그램이 필요합니다.

- Linux: [sudo] apt-get install graphviz

- OSX:
	- MacPorts: sudo port install graphviz
	- Homebrew: brew install graphviz
- [Windows](https://graphviz.gitlab.io/download/#Windows) (untested)

### 구글 크롬

엑스큐선 트레이서 섹션에서 구글 크롬이 필요하다. Safari, Edge, Firefox 또는 IE 4.01에서는 작동하지 않는다. 배터리에게 미안하다고 말해주세요.

### 프로파일하고 최적화를 위한 자신의 코드

하루의 마지막 부분은 배운 도구로 실험을 할 수 있는 공개 세션이 될 것입니다.

### 한 가지 더

이건 강의가 아니라 대화입니다. 질문을 할 수 있는 많은 휴식 시간을 가질 겁입니다.

만약 여러분이 무언가를 이해하지 못하거나, 여러분이 듣고 있는 것이 정확하지 않다고 생각한다면, 물어보세요.

## 1. 마이크로 프로세서의 과거, 현재, 그리고 미래 

고성능 코드를 작성하는 것에 대한 워크샵입니다. 다른 워크샵에서는 디커플된 설계와 유지보수성에 대해 이야기하지만, 오늘은 성능에 대해 이야기하려고 합니다.

저는 오늘 컴퓨터의 진화의 역사에 대해 어떻게 생각하는지 그리고 왜 고성능 소프트웨어를 작성하는 것이 중요하다고 생각하는지에 대한 짧은 강의로 시작하고 싶습니다.

실제로 소프트웨어는 하드웨어에서 실행되므로 고성능 코드 작성에 대해 이야기하려면 먼저 코드를 실행하는 하드웨어에 대해 이야기해야 합니다.

### 1.1 기계적 공감

![](https://dave.cheney.net/high-performance-go-workshop/images/image-20180818145606919.png)

지금 인기 있는 문구가 있는데, 마틴 톰슨(Martin Thompson)이나 빌 케네디(Bill Kennedy) 같은 사람들이 "기계적인 공감"에 대해 이야기하는 것을 들을 수 있습니다.

"기계적 공감"이라는 이름은 세계 3대 포뮬라 1 챔피언인 위대한 경주 자동차 드라이버인 재키 스튜어트(Jackie Stewart)에서 유래했습니다. 그는 최고의 운전자는 기계가 어떻게 작동하는지 충분히 이해하고 있어서 기계와 조화를 이룰 수 있다고 믿었습니다.

훌륭한 경주용 자동차 드라이버가 되기 위해서는 훌륭한 정비사가 될 필요는 없지만, 자동차 작동 방식에 대한 호기심 이상의 이해가 필요합니다.

소프트웨어 엔지니어들도 마찬가지라고 생각합니다. 저는 이 자리에 계신 여러분 중 누구도 전문적인 CPU 디자이너가 되지는 않을 것이라고 생각합니다. 하지만 그렇다고 해서 CPU 디자이너들이 직면하고 있는 문제들을 무시할 수는 없습니다.

### 1.2 6자리 수의 크기

이와 같은 일반적인 인터넷 밈이 있습니다.

![](https://dave.cheney.net/high-performance-go-workshop/images/jalopnik.png)

물론 말도 안 되는 소리이지만, 이는 컴퓨터 업계에서 얼마나 많은 변화가 일어났는지를 잘 보여주고 있습니다.

이 자리에 모인 소프트웨어 작가들은 모두 무어의 법칙의 혜택을 받아왔기 때문에, 40년 동안 18개월마다 칩에서 사용할 수 있는 트랜지스터의 수가 두 배로 증가했습니다. 평생동안 툴이 6자리 수의 크기로 향상된 산업 분야는 없습니다.

하지만 이 모든 것이 변하고 있습니다.

### 1.3 컴퓨터는 여전히 더 빨라지고 있나요?

그래서 근본적인 질문은, 위의 그림에서와 같은 통계와 마주치게 됩니다. 우리는 컴퓨터가 여전히 더 빨라지고 있는지 물어봐야 할까요?

컴퓨터가 여전히 빨라지고 있다면, 코드 성능에 신경 쓸 필요가 없습니다. 조금만 기다리면 하드웨어 제조업체가 성능 문제를 해결할테니깐요.

#### 1.3.1 데이터를 살펴봅시다.

이것은 컴퓨터 아키텍처, 존 해네시(John L. Hennessy)의 정량적 접근(A Quantitative Approach, David A. Patterson)과 같은 교과서에서 볼 수 있는 고전적인 데이터입니다. 이 그래프는 5판에서 가져왔습니다.

![](https://community.cadence.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-01-06/2313.processorperf.jpg)

5판에서 헤네시(Hennessey)와 패터슨(Patterson)은 세 가지 컴퓨팅 성능 시대가 있다고 주장합니다.

- 첫 번째는 1970년대와 80년대 초였으며, 형성기였습니다. 오늘날 우리가 알고 있는 마이크로프로세서는 실제로 존재하지 않았습니다. 컴퓨터는 개별 트랜지스터나 소형 집적회로에서 제작되었습니다. 재료 과학의 비용, 크기, 그리고 이해의 한계가 제한 요인이었습니다.

- 80년대 중반부터 2004년까지 추세선은 명확합니다. 컴퓨터 정수 성능이 매년 평균 52% 향상되었습니다. 컴퓨터 전력은 2년마다 두 배씩 증가했기 때문에 사람들은 다이의 트랜지스터 수를 두 배로 늘려가며 무어의 법칙과 컴퓨터 성능을 혼용하였습니다.

- 그리고 나서 우리는 컴퓨터 성능의 세 번째 시대에 도달했습니다. 느려집니다. 총 변동률은 연간 22%입니다.

이전 그래프는 2012년까지만 올라갔지만, 다행히도 2012년 [Jeff Preshing](http://preshing.com/20120208/a-look-back-at-single-threaded-cpu-performance/)은 [Spec 웹 사이트를 스크래치하고 자신만의 그래프를 만드는 도구](https://github.com/preshing/analyze-spec-benchmarks)를 작성했습니다.

![](https://dave.cheney.net/high-performance-go-workshop/images/int_graph.png)

이것은 1995년부터 2017년까지 Spec 데이터를 사용한 것과 동일한 그래프입니다.

2012년 데이터에서 살펴본 단계 변화보다는 단일 코어 성능이 한계에 근접하고 있다고 말씀드리고 싶습니다. 부동 소수점보다 숫자가 더 좋지만, 이 자리에 있는 비즈니스 애플리케이션 라인의 업무를 수행하는 저희에게 있어, 그다지 관련이 없을 것입니다.

#### 1.3.2 네, 컴퓨터는 여전히 더 빨라지고 있어요, 천천히

> 무어의 법칙 끝에서 가장 먼저 기억해야 할 것은 고든 무어 (Gordon Moore)가 내게 얘기한 것입니다. 그는 "모든 지수가 끝나고 있다"고 말했습니다. — 존 헤네시


이것은 Hennessy가 Google Next 18에서 그의 Turing Award 강연에서 인용한 것입니다. 그의 주장은 네, CPU 성능은 여전히 향상되고 있습니다. 그러나 단일 스레드 정수(Integer) 성능은 아직 연간 약 2~3% 개선되고 있습니다. 이런 속도라면 정수의 성능을 두 배로 끌어올리기 위해 20년의 복합 성장(Compound Growth)을 해야할 것입니다. 이를 2년마다 성능이 2배씩 증가한 90년대의 Go-Go 시대와 비교해야 합니다.

왜 이런 일이 일어나는 걸까요?

### 1.4 클럭 속도

![](https://dave.cheney.net/high-performance-go-workshop/images/stuttering.png)

2015년도의 그래프가 이를 잘 보여줍니다. 상단 라인은 다이에서 트랜지스터의 수를 나타냅니다. 이것은 1970년대 이후로 거의 선형적인 추세선상에서 지속되어 왔습니다. 로그/린 그래프이기 때문에 이 선형 계열은 지수 성장을 나타냅니다.

하지만, 중간 라인을 보면, 10년 동안 클럭 속도가 증가하지 않았으며 2004년경에 CPU 속도가 정체된 것을 알 수 있습니다.

하단 그래프는 열 분산 전력을 보여 줍니다. 즉, 열로 변환되는 전력은 동일한 패턴을 따릅니다. 클럭 속도와 CPU 열 분산은 서로 관련이 있습니다.

### 1.5 열

CPU가 열을 발생시키는 이유는 무엇일까요? 고체 상태 장치(Solid State Device)이고 움직이는 구성 요소가 없으므로 마찰과 같은 효과는 (직접적으로) 관련이 없습니다.

이 다이어그램은 [TI에서 제작한 훌륭한 데이터 시트](http://www.ti.com/lit/an/scaa035b/scaa035b.pdf)에서 가져온 것입니다. 이 모델에서 N 타입 장치의 스위치는 양극 전압으로 끌어 당겨집니다. P 타입 디바이스는 양극 전압에서 쫓겨납니다.

![](https://dave.cheney.net/high-performance-go-workshop/images/cmos-inverter.png)

이 방, 여러분의 책상, 그리고 여러분의 주머니에 있는 모든 트랜지스터에 사용되는 CMOS 기기의 전력 소비량은 세 가지 요인의 조합입니다.

- 정적 전력. 트랜지스터가 정적인 경우 즉, 상태를 변경하지 않으면 트랜지스터를 통해 접지로 누설되는 소량의 전류가 있습니다. 트랜지스터가 작을수록 누설이 많아집니다. 온도가 높아지면 누수가 증가합니다. 수십억 개의 트랜지스터가 있으면 1분이라도 누출이 발생합니다!

- 동적 전력. 트랜지스터가 한 상태에서 다른 상태로 전이될 때, 트랜지스터는 게이트에 연결된 다양한 커패시턴스를 충전하거나 방전해야 합니다. 트랜지스터당 동적 전력은 제곱한 전압 곱하기 커패시턴스와 변화 빈도입니다. 전압을 낮추면 트랜지스터가 소비하는 전력이 감소하지만 전압이 낮으면 트랜지스터가 느리게 전환됩니다.

- 크라우바 또는 단락 전류. 우리는 트랜지스터를 원자 상태에서 하나의 상태 또는 다른 상태를 차지하는 디지털 장치로 생각합니다. 실제로 트랜지스터는 아날로그 장치입니다. 스위치로서 트랜지스터는 대부분 오프 상태에서 시작하여 온 상태로 전이 또는 전환됩니다. 이러한 전이 또는 전환 시간은 매우 빠릅니다. 현대 프로세서에서는 피코 초의 단위이지만, Vcc에서 접지로의 저항 경로가 있을 때 여전히 어느 정도의 시간이 걸립니다. 트랜지스터의 전환 속도가 빠를수록 더 많은 열이 방출됩니다.

### 1.6 Dennard 스케일링의 끝

다음에 무슨 일이 일어났는지 이해하려면 1974년에 로버트 H. 데너드(Robert H. Dennard)가 공동 저술한 논문을 살펴봐야 합니다. 데너드의 스케일링 법칙에 따르면 트랜지스터가 작아질수록 전력 밀도는 일정하게 유지됩니다. 트랜지스터가 작아질수록 전압도 낮아지고, 게이트 커패시턴스도 낮아지며, 스위치 속도도 빨라져 동적 전력량을 줄일 수 있습니다.

그래서 어떻게 해결되었을까요?

![](http://semiengineering.com/wp-content/uploads/2014/04/Screen-Shot-2014-04-14-at-8.49.48-AM.png)

결과는 별로 좋지 않습니다. 트랜지스터의 게이트 길이가 몇 개의 실리콘 원자의 너비에 접근함에 따라 트랜지스터 크기, 전압 및 중요한 누설 사이의 관계가 끊어졌습니다.

[1999년 Micro-32 컨퍼런스](https://pdfs.semanticscholar.org/6a82/1a3329a60def23235c75b152055c36d40437.pdf)에서 클럭 속도를 높이고 트랜지스터 크기를 줄이는 추세를 따랐다면 프로세서 세대 내에서 트랜지스터 접합부가 원자로 노심 온도에 근접할 것이라고 가정했습니다. 분명히 이것은 미친 짓입니다. 펜티엄 4는 단일 코어, 고주파, 소비자 CPU [라인의 종지부를 찍었습니다](https://arstechnica.com/uncategorized/2004/10/4311-2/).

이 그래프로 돌아와서, 클럭 속도가 멈춘 이유는 CPU의 속도가 CPU를 냉각시키는 능력을 초과했기 때문입니다. 2006년까지 트랜지스터 크기의 감소로 전력 효율은 더 이상 개선되지 않습니다.

이제 CPU 피처 크기 감소는 주로 전력 소비를 줄이는 데 목적이 있다는 것을 알게 되었습니다. 전력 소비량을 줄인다고 해서 단순히 지구를 살리는 재활용과 같은 "친환경"을 의미하는 것이 아닙니다. 주된 목표는 전력 소비를 유지하고, 그러한 열 손실로, [CPU를 손상시키는 수준을 낮추는](https://en.wikipedia.org/wiki/Electromigration#Practical_implications_of_electromigration) 것입니다.

![](https://dave.cheney.net/high-performance-go-workshop/images/stuttering.png)

하지만, 그래프의 한 부분, 다이(Die)에 있는 트랜지스터의 수는 계속 증가하고 있습니다. 주어진 동일한 영역에 더 많은 트랜지스터를 집적하는 CPU 피처 크기의 행진은 긍정적인 효과와 부정적인 효과 모두를 지닙니다.

또한, 인서트에서도 볼 수 있듯이 트랜지스터당 비용은 5년 전까지 계속 하락했습니다. 그 이후 트랜지스터당 비용이 다시 상승하기 시작했습니다.

![](https://whatsthebigdata.files.wordpress.com/2016/08/moores-law.png)

더 작은 트랜지스터를 만드는 데 더 많은 비용이 들 뿐만 아니라 더 어려워지고 있습니다. 2016년의 이 보고서는 칩 제조업체들에게 2013년 격게 될 일의 예측을 보여줍니다. 2년 후 그들의 모든 예측이 빗나갔습니다. 이 보고서의 최신 버전은 없지만 이러한 추세를 되돌릴 수 있을 것 같은 징후는 보이지 않습니다.

인텔, TSMC, AMD, 그리고 삼성은 새로운 공장을 짓고 새로운 프로세스 툴링을 구매해야하기 때문에 수십억 달러의 비용이 듭니다. 그래서 다이당 트랜지스터 수가 계속 상승하면서, 그들의 단가가 상승하기 시작했습니다.

> 나노미터 단위로 측정한 게이트 길이라는 용어도 모호해졌습니다. 다양한 제조업체는 트랜지스터 크기를 다양한 방식으로 측정하여 실제로 전달하지 않고도 경쟁업체보다 적은 수의 트랜지스터를 시연할 수 있습니다. CPU 제조업체의 비 GAAP 수익 보고 모델입니다.
> 

### 1.7 더 많은 코어

![](https://i.redd.it/y5cdp7nhs2uy.jpg)

열 및 주파수 한계에 도달하면 단일 코어 속도를 2배 빠르게 실행할 수 없습니다. 그러나 다른 코어를 추가하면 소프트웨어에서 지원할 수 있는 경우 처리 용량을 두 배로 제공할 수 있습니다.

실제로 CPU의 코어 수는 열 분산에 의해 좌우됩니다. Dennard 스케일링의 끝은 CPU의 클럭 속도가 얼마나 뜨겁는지에 따라 1~4Ghz 사이의 임의의 숫자임을 의미합니다. 벤치마킹에 대해 이야기할 때 곧 이것을 보게 될 것입니다.

### 1.8 암달의 법칙

CPU는 점점 더 빨라지지는 않지만, 하이퍼 스레딩과 다중 코어로 점점 더 확장되고 있습니다. 모바일 부품에 듀얼 코어, 데스크톱 부품에 쿼드 코어, 서버 부품에 수십 개의 코어. 이것이 컴퓨터 성능의 미래일까요? 불행히도 그렇지 않습니다.

IBM/360의 설계자인 진 암달(Gene Amdahl)의 이름을 딴 암달의 법칙은 리소스가 개선된 시스템에서 기대할 수 있는 고정 워크로드에서의 작업 실행의 대기 시간을 이론적으로 가속화하는 공식입니다.

![](https://upload.wikimedia.org/wikipedia/commons/e/ea/AmdahlsLaw.svg)

암달의 법칙에 따르면 프로그램의 최대 속도는 프로그램의 순차적인 부분에 의해 제한됩니다. 실행의 95%를 병렬로 실행할 수 있는 프로그램을 작성하는 경우, 수천 개의 프로세서를 사용하더라도 프로그램 실행의 최대 속도는 20배로 제한됩니다.

우리가 매일 작업하는 프로그램에 대해 생각해봅시다. 얼마나 많이 병렬로 실행할 수 있을까요?

### 1.9 동적 최적화

클럭 속도가 지연되고, 추가 코어를 투척해도 이익이 제한되는 문제점이 있을 때, 속도 향상은 어디서 오는 것일까요? 칩 자체의 아키텍처를 개선한 결과입니다. 이들은 [Nehalem](https://en.wikipedia.org/wiki/List_of_Intel_CPU_microarchitectures#Pentium_4_/_Core_Lines), [Sandy Bridge](https://en.wikipedia.org/wiki/List_of_Intel_CPU_microarchitectures#Pentium_4_/_Core_Lines), 및 [Skylake](https://en.wikipedia.org/wiki/List_of_Intel_CPU_microarchitectures#Pentium_4_/_Core_Lines)와 같은 이름을 지는 5~7년 짜리의 큰 프로젝트입니다.

지난 20년 동안의 성능 향샹은 아키텍처 개선에서 비롯되었습니다.

#### 1.9.1 비순차적 명령어 처리 (Out of order execution)

슈퍼 스칼라라고 하는 비순차적 실행은 CPU가 실행 중인 코드에서 소위 명령어 수준 병렬 처리를 추출하는 방법입니다. 최신 CPU는 하드웨어 수준에서 SSA를 효과적으로 수행하여 작업 간의 데이터 종속성을 식별하고 가능한 경우 독립적인 명령을 병렬로 실행합니다.

그러나 모든 코드에 내재된 병렬 처리량에는 제한이 있습니다. 엄청나게 힘도 듭니다. 대부분의 최신 CPU는 파이프 라인의 각 단계에서 각 실행 장치를 다른 모든 장치에 연결하는데 n 제곱의 비용이 발생하기 때문에 코어당 6개의 실행 장치로 정착했습니다.

#### 1.9.2 추측 실행 (Speculative execution)

가장 작은 마이크로 컨트롤러를 저장하면, 모든 CPU는 명령 페치/디코딩/실행/커밋 사이클의 일부와 겹치는 명령 파이프라인을 활용합니다.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Fivestagespipeline.png/800px-Fivestagespipeline.png)

명령어 파이프 라인의 문제는 분기 명령어이며 평균 5-8 명령어마다 발생합니다. CPU가 분기에 도달하면 분기를 넘어 추가적인 명령을 실행할 수 없으며 프로그램 카운터도 분기할 위치를 알 때까지 파이프 라인 채우기를 시작할 수 없습니다. 추측 실행은 CPU가 분기 명령이 여전히 처리되고 있는 중에도 어느 경로로 분기해야할지 "추측"할 수 있게 합니다!

CPU가 분기를 올바르게 예측하면 명령 파이프 라인을 가득 채울 수 있습니다. CPU가 올바른 분기를 예측하지 못하고 오류로 인식하면 아키텍처 상태에 대한 변경 사항을 롤백해야 합니다. 우리 모두가 Spectre 스타일의 취약점을 배우고 있기 때문에, 때때로 이 롤백은 기대만큼 원활하지 않은 경우가 있습니다.

분기 예측률이 낮을 때, 추측 실행이 매우 어려울 수 있습니다. 분기가 잘못 예측된 경우, CPU 역추적은 잘못 예측한 지점까지 역추적해야할 뿐만 아니라 잘못된 분기에서 소비된 에너지가 낭비됩니다.

이러한 모든 최적화로 인해 수많은 트랜지스터와 전력 비용으로 단일 스레드 성능이 향상되었습니다.

> 클리프 클릭(Cliff Click)은 비순차적 및 추론적 실행은 캐시 미스를 조기에 시작하여 관찰된 캐시 대기 시간을 줄이는데 가장 유용하다고 논증하는 [훌륭한 프리젠테이션](https://www.youtube.com/watch?v=OFgxAFdxYAQ)을 제공합니다.

### 1.10 현대 CPU는 벌크 동작에 대해 최적화되었습니다.

> 현대의 프로세서는 니트로 연료가 함유된 재미있는 자동차와 비슷하며 쿼터 마일에서 뛰어납니다. 불행히도 현대의 프로그래밍 언어는 Monte Carlo와 비슷하지만 트위스트와 턴으로 가득합니다. — 데이비드 언가(David Ungar)

이는 영향력있는 컴퓨터 과학자이자 SELF 프로그래밍 언어의 개발자인 데이비드 언가의 인용문으로 온라인에서 찾은 아주 오래된 프리젠테이션에서 언급되었습니다.

따라서 최신 CPU는 대량 전송 및 대량 작업에 최적화되어 있습니다. 모든 레벨에서 작업 설정 비용은 대량 작업을 권장합니다. 예를 들어, 다음과 같습니다.

- 메모리는 바이트당 로드되지 않고 여러 캐시 라인마다 로드되므로 정렬이 이전 컴퓨터에서만큼 문제가 되지않는 이유입니다.
- MMX 및 SSE와 같은 벡터 명령을 사용하면 프로그램이 해당 형식으로 표현될 수 있는 동시에 다중 데이터 항목에 대해 단일 명령을 실행할 수 있습니다.

### 1.11 현대 프로세서는 메모리 용량이 아닌 메모리 지연 시간으로 제한됩니다.

CPU 땅의 상황이 그다지 나쁘지 않았다면, 집의 메모리 쪽에서 들려오는 뉴스는 크게 나아지지 않습니다.

서버에 연결된 물리적 메모리가 기하학적으로 증가했습니다. 1980년대에 저의 첫 컴퓨터는 킬로바이트의 메모리를 가지고 있었습니다. 고등학교를 다닐 때 저는 386에 1.8메가바이트의 램을 가지고 모든 에세이를 썼습니다. 이제 수십 기가바이트 또는 수백 기가바이트의 램을 가진 서버를 찾는 것이 일반적이며, 클라우드 공급업체는 테라바이트의 램을 도입하고 있습니다.

그러나 프로세서 속도와 메모리 액세스 시간 사이의 간극이 계속 증가하고 있습니다.

![](https://www.extremetech.com/wp-content/uploads/2018/01/mem_gap.png)

하지만, 메모리 대기 중에 손실된 프로세서 싸이클의 경우, 메모리가 CPU 속도의 증가에 보조를 맞추지 못했기 때문에 물리적 메모리는 그 어느때보다 여전히 멀리 떨어져 있습니다.

따라서 대부분의 최신 프로세서는 용량이 아닌 메모리 대기 시간으로 제한됩니다.

![](https://pbs.twimg.com/media/BmBr2mwCIAAhJo1.png)

### 1.12 캐시가 주변의 모든 것을 지배합니다.

![](https://www.extremetech.com/wp-content/uploads/2014/08/latency.png)

수십 년 동안 프로세서/메모리 캡에 대한 솔루션은 캐시를 추가하는 것이 었습니다. 캐시는 CPU에 더 가까이, 이제는 직접 통합된 작은 고속 메모리입니다.

그러나;

- L1은 수십 년 동안 코어 당 32kb로 고정되었습니다.

- L2는 가장 큰 인텔 부품에서 최대 512kb까지 천천히 상승했습니다.

- L3는 이제 4-32mb 범위에서 측정되지만 액세스 시간은 가변적입니다.

![](https://i3.wp.com/computing.llnl.gov/tutorials/linux_clusters/images/E5v4blockdiagram.png)

캐시는 [CPU 다이에서 물리적으로 크기 때문에](http://www.itrs.net/Links/2000UpdateFinal/Design2000final.pdf) 크기가 제한되어 많은 전력을 소비합니다. 캐시 미스율을 절반으로 줄이려면 캐시 크기를 4배로 늘려야합니다.

### 1.13 공짜 점심은 끝났다.

2005년 C++위원회 리더인 허브 서터(Herb Sutter)는 [공짜 점심은 끝났다](http://www.gotw.ca/publications/concurrency-ddj.htm)라는 제목의 기사를 썼습니다. 그의 글에서 Sutter는 제가 다룰 모든 점에 대해 논의했으며 미래 프로그래머는 더 이상 느린 프로그램 또는 느린 프로그래밍 언어를 수정하기 위해 더 빠른 하드웨어에 의존할 수 없을 것이라고 주장했습니다..

10년이 지난 지금, 허브 서터가 옳았다는 것에는 의심의 여지가 없습니다. 메모리가 느리고 캐시가 너무 작고, CPU 클럭 속도가 거꾸로 가고 있으며 단일 스레드 CPU의 단순한 세계는 오래 전에 사라졌습니다.

무어의 법칙은 여전히 유효하지만, 이 자리에 있는 우리 모두에게 공짜 점심은 끝이 났습니다.


### 1.14 결론

> 제가 인용하고자하는 숫자는 2010년까지 30GHz, 100억 개의 트랜지스터, 초당 1테라 명령입니다. — [Pat Gelsinger, Intel CTO, 2002년 4월](https://www.cnet.com/news/intel-cto-chip-heat-becoming-critical-issue/)

재료 과학의 획기적인 발전없이는 CPU 성능의 연간 증가율 52%의 시대로 돌아올 가능성이 거의 없다는 것이 분명합니다. 일반적인 합의는 결함이 재료 과학 자체가 아니라 트랜지스터 사용 방법에 있다는 것입니다. 실리콘으로 표현된 순차적 명령 흐름의 논리적 모델은 이러한 고가의 최종 게임으로 이어집니다.

온라인에 많은 프리젠테이션이 이 점을 반복하고 있습니다. 미래에는 컴퓨터가 오늘날처럼 프로그래밍되지 않을 것입니다. 일부는 수백 개의 매우 멍청하고 일관성이없는 프로세서를 갖춘 그래픽 카드처럼 보일 것이라고 주장합니다. 다른 사람들은 VLIW (Very Long Instruction Word) 컴퓨터가 우세할 것이라고 주장합니다. 현재 순차 프로그래밍 언어는 이러한 종류의 프로세서와 호환되지 않을 것이라는 데 모두 동의합니다.
 
제 생각에는 이러한 예측이 정확하다는 것입니다. 이 시점에서 우리를 구해온 하드웨어 제조업체에 대한 전망은 어둡습니다. 그러나 오늘날 우리가 쓰는 하드웨어에 작성하는 프로그램을 최적화할 수 있는 광범위한 범위가 있습니다. 릭 허드슨(Rick Hudson)은 GopherCon 2015에서 오늘날의 하드웨어와 무관하지 않게 동작하는 소프트웨어의 "유연한 순환"에 다시 참여하는 것에 대해 말했습니다.

앞서 보여드린 그래프를 보면, 2015년부터 2018년까지 정수의 성능은 기껏해야 5~8% 향상되고 메모리 대기 시간은 이보다 적은 것으로 나타났는데, Go팀은 가비지 콜렉션 일시 중지 시간을 2자리 수의 크기로 줄였습니다. Go 1.11 프로그램은 Go 1.6을 사용하는 동일한 하드웨어의 동일한 프로그램보다 GC 대기 시간이 훨씬 뛰어납니다. 이 중 어느 것도 하드웨어에서 비롯된 것이 아닙니다.

따라서, 오늘날의 오늘날 하드웨어에서 최상의 성능을 얻으려면 다음과 같은 프로그래밍 언어가 필요합니다.

- 해석된 프로그래밍 언어가 CPU 분기 예측 변수 및 추론 실행과 제대로 상호 작용하지 않기 때문에 해석되지 않고 컴파일됩니다.

- 효율적인 코드를 작성할 수 있는 언어가 필요하며, 모든 숫자가 이상적인 부동 소수인 척 하기보다는 비트와 바이트, 정수의 길이에 대해 효과적으로 얘기할 수 있어야 합니다.

- 프로그래머가 메모리에 대해 효과적으로 이야기하고 구조체와 자바 객체를 생각할 수있는 언어가 필요합니다. 왜냐하면 포인터 추적이 CPU 캐시에 압력을 가하고 캐시 미스가 수백 번의 사이클을 태우기 때문입니다.

- 애플리케이션 성능에 따라 여러 코어로 확장되는 프로그래밍 언어는 캐시를 얼마나 효율적으로 사용하고 여러 코어에서 작업을 얼마나 효율적으로 병렬화할 수 있는지에 따라 결정됩니다.

분명히 우리는 Go에 대해 이야기하러 여기에 왔습니다. 그리고 저는 Go가 방금 설명한 많은 특징들을 물려받았다고 믿습니다.

#### 1.14.1 우리와 무슨 상관이 있나요?

> 최적화는 세 가지 뿐입니다. 적게 하세요. 덜 자주하세요. 더 빨리 하세요.
> 가장 큰 이득은 첫 번째에서 비롯되지만, 우리는 모든 시간을 세 번째에서 소비합니다. — Michael Fromberger

이 강의의 요점은 프로그램이나 시스템의 성능에 대해 이야기 할 때 전적으로 소프트웨어에 있음을 설명하는 것입니다. 더 빠른 하드웨어가 하루를 구하기를 기다리는 것은 어리석은 일입니다.

그러나 좋은 소식이 있습니다. 소프트웨어에서 할 수 있는 많은 개선 사항들이 있습니다. 그리고 그것이 오늘 이야기하고자 하는 것입니다.

#### 1.14.2 더 읽을 거리 

- [The Future of Microprocessors, Sophie Wilson](https://www.youtube.com/watch?v=zX4ZNfvw1cw) JuliaCon 2018
- [50 Years of Computer Architecture: From Mainframe CPUs to DNN TPUs, David Patterson](https://www.youtube.com/watch?v=HnniEPtNs-4)
- [The Future of Computing, John Hennessy](https://web.stanford.edu/~hennessy/Future%20of%20Computing.pdf)
- [The future of computing: a conversation with John Hennessy](https://www.youtube.com/watch?v=Azt8Nc-mtKM) (Google I/O '18)