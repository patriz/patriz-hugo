+++
date          = "2018-12-05T12:58:00+00:00"
draft         = true
title         = "[번역] 확장 가능한 포터블 도커 컨테이너 네트워크 디자인"
tags          = ["Networking", "Docker"]
categories    = ["DevOps"]
slug          = "designing-scalable-portable-docker-container-networks"
notoc         = false
socialsharing = true
nocomment     = false
+++


# 배우게 될 것

도커 컨테이너는 실행에 필요한 모든 것, 즉 코드, 런타임, 시스템 도구, 시스템 라이브러리 등 서버에 설치할 수 있는 모든 것을 포함하는 완전한 파일 시스템에 있는 소프트웨어 하나를 래핑한다. 이는 소프트웨어가 환경에 관계없이 항상 동일한 기능을 실행할 것을 보장한다. 기본적으로 컨테이너는 애플리케이션을 서로 격리하고, 애플리케이션을 위한 추가적인 보호 계층을 제공한다.

애플리케이션이 서로 간에, 또는 호스트와, 혹은 외부 네트워크와 통신해야 한다면 어떻게 해야하는가? 애플리케이션 이식성, 서비스 검색, 로드 밸런싱, 보안, 성능 및 확장성을 유지하면서 적절한 연결성을 위해 네트워크를 설계하는 방법은 무엇인가? 이 문서는 이러한 네트워크 설계 문제와 사용 가능한 도구 및 일반적인 배포 패턴을 다룬다. 물리적 네트워크 설계를 지정하거나 권장하지는 않지만 애플리케이션과 물리적 네트워크의 제약조건을 고려하면서 도커 네트워크를 설계하는 방법에 대한 옵션들을 제공한다.

## 사전 지식
계속하기 전에 도커 개념과 도커 스웜에 대해 잘 알고 있어야 한다.

- [도커 개념](https://docs.docker.com/engine/understanding-docker/)
- [도커 스웜 및 스웜 모드 개념](https://docs.docker.com/engine/swarm/key-concepts/#/services-and-tasks)

# 네트워킹 컨테이너 및 마이크로 서비스의 도전

마이크로서비스는 실전에서 애플리케이션의 스케일을 증가시켰는데, 이러한 애플리케이션들은 제공되는 연결성 및 격리 방법들이 훨씬 더 중시된다. 도커 네트워킹 철학은 애플리케이션 중심이다. 네트워크 운영자에게 옵션과 유연성을 제공하는 것을 목표로 하는 것 뿐만 아니라 애플리케이션 개발자에게 적합한 수준의 추상화를 제공하는 것을 목표로 한다.

여느 디자인처럼, 네트워크 디자인은 밸런스을 맞추는 행위이다. 도커 엔터프라이즈 에디션과 도커 생태계는 네트워크 엔지니어들에게 그들의 애플리케이션과 환경에 대한 최상의 밸런스를 달성하기 위해 다양한 도구를 제공한다. 각 옵션은 서로 다른 장점과 트레이드오프를 제공한다. 이 가이드의 나머지 부분에서는 네트워크 엔지니어가 자신의 환경에 가장 적합한 것을 이해할 수 있도록 이러한 각각 선택에 대해 자세히 설명한다.

도커는 애플리케이션을 공급하는 새로운 방법을 개발했고, 그와 함께 컨테이너는 네트워킹 접근 방식의 일부 측면도 변화시켰다. 다음 주제는 컨테이너형 애플리케이션에 대한 일반적인 디자인 주제이다.

- **이식성**
	- 고유한 네트워크 특성을 활용하면서 다양한 네트워크 환경에서 최대한의 이식성을 어떻게 보장할 수 있는가?

- **서비스 검색**
	- 서비스가 확장 및 축소될 때 어디에 살고 있는지 어떻게 알 수 있는가?

- **로드 밸런싱**
	- 서비스 자체가 커지고 확장될 때 서비스 간에 부하를 어떻게 공유하는가?

- **보안**
	- 잘못된 컨테이너가 서로 액세스하지 못하도록 어떻게 구분하는가?
	- 애플리케이션 및 클러스터 제어 트래픽이 있는 컨테이너가 안전하다는 것을 어떻게 보장하는가?

- **성능**
	- 대기 시간을 최소화하고 대역폭을 최대화하는 동시에 고급 네트워크 서비스를 어떻게 제공하는가?

- **확장성**
	- 여러 호스트에 걸쳐 애플리케이션을 확장할 때 이러한 특성들이 저하되지 않도록 하려면 어떻게 하는가?


# 컨테이너 네트워킹 모델

도커 네트워킹 아키텍처는 CNM(Container Networking Model)이라고 하는 인터페이스 집합 위에 구축된다. CNM의 철학은 다양한 인프라 구조에서 애플리케이션 이식성을 제공하는 것이다. 이 모델은 애플리케이션 이식성을 달성하기 위해 밸런스를 맞추고 인프라의 특수 기능과 역량을 활용한다.

![](https://success.docker.com/api/images/.%2Frefarch%2Fnetworking%2Fimages%2Fcnm.png)

## CNM 구조

CNM에는 몇 가지 상위 레벨의 구조가 있다. 이들은 모두 OS 및 인프라에 구애받지 않으므로 인프라 스택에 관계없이 애플리케이션이 동일한 환경을 가질 수 있다.

- **샌드박스** - 샌드박스는 컨테이너 네트워크 스택의 구성을 포함한다. 여기에는 컨테이너 인터페이스, 라우팅 테이블 및 DNS 설정 관리가 포함된다. 샌드박스의 구현은 Linux 네트워크 네임스페이스, FreeBSD Jail 또는 기타 유사한 개념일 수 있다. 샌드박스는 여러 네트워크의 많은 엔드포인트를 포함할 수 있다.
- **엔드포인트** - 엔드포인트가 샌드박스를 네트워크에 연결한다. 엔드포인트의 구조는 네트워크에 대한 실제 연결을 애플리케이션에서 추상화할 수 있도록 존재한다. 이는 서비스가 네트워크에 어떻게 연결되어 있는지에 신경쓰지 않으며 여러 유형의 네트워크 드라이버를 사용할 수 있도록 이식성을 유지하는데 도움을 준다.
- **네트워크** — CNM은 OSI 모델 측면에서 네트워크를 지정하지 않는다. 네트워크의 구현은 리눅스 브리지, VLAN 등이 될 수 있다. 네트워크는 이들 사이에 연결성이 있는 엔드포인트의 모음이다. 네트워크에 연결되지 않은 엔드포인트는 네트워크에 연결되어 있지 않다.

## CNM 드라이버 인터페이스
컨테이너 네트워킹 모델은 사용자, 커뮤니티 및 벤더가 네트워크에서 추가 기능, 가시성 또는 제어 기능을 활용할 수 있는 2개의 플러그형 및 개방형 인터페이스를 제공한다.

다음 네트워크 드라이버가 있다:

- **네트워크 드라이버** - 도커 네트워크 드라이버는 네트워크를 작동시키는 실제 구현을 제공한다. 다른 드라이버를 사용할 수 있고 다양한 유스케이스를 쉽게 지원할 수 있도록 상호 교환될 수 있는 플러그 스타일이다. 주어진 도커 엔진 또는 클러스터에서 여러 개의 네트워크 드라이버를 동시에 사용할 수 있지만, 각 도커 네트워크는 단일 네트워크 드라이버를 통해서만 인스턴스화된다. CNM 네트워크 드라이버는 크게 두 가지 유형이 있다.
	- **네이티브 네트워크 드라이버** - 네이티브 네트워크 드라이버는 도커 엔진의 기본 요소이며 도커에서 제공한다. 오버레이 네트워크나 로컬 브리지와 같은 다양한 기능을 지원하는 여러 드라이버가 있다.
	- **원격 네트워크 드라이버** - 원격 네트워크 드라이버는 커뮤니티와 다른 벤더가 생성한 네트워크 드라이버이다. 이러한 드라이버는 기존 소프트웨어 및 하드웨어와의 통합을 제공할 수 있다. 사용자는 또한 기존 네트워크 드라이버가 지원하지 않는 특정 기능을 원하는 경우 자신의 드라이버를 만들 수도 있다.
- **IPAM 드라이버** - 도커에는 네트워크 및 엔드포인트의 기본 서브넷 또는 IP 주소를 지정하지 않은 경우 이를 제공하는 네이티브 IP 주소 관리 드라이버가 있다. IP 어드레싱은 네트워크, 컨테이너 및 서비스 생성 명령을 통해 수동으로 할당할 수도 있다. 원격 IPAM 드라이버도 존재하며 기존 IPAM 도구와 통합된다.

![](https://success.docker.com/api/images/.%2Frefarch%2Fnetworking%2Fimages%2Fcnm-api.png)


## 도커 네이티브 네트워크 드라이버

도커 네이티브 네트워크 드라이버는 도커 엔진의 일부이므로 추가 모듈은 필요없다. 이들은 표준 `docker network` 명령을 통해 호출되고 사용된다. 다음과 같은 네이티브 네트워크 드라이버가 있다.

|  드라이버  |  설명  |
| -------- | ---- |
| Host     | `host` 드라이버가 있는 호스트 컨테이너는 호스트의 네트워킹 스택을 사용함. 네임스페이스 분리가 없으므로 호스트의 모든 인터페이스를 컨테이너에서 직접 사용할 수 있음.|
| Brdige   | `bridge` 드라이버는 도커가 관리하는 호스트에 리눅스 브리지를 생성함. 기본적으로 브리지의 컨테이너는 서로 통신할 수 있음. 또한 브리지 드라이버를 통해 컨테이너에 대한 외부 액세스를 구성할 수 있음. |
| Overlay  | `overlay` 드라이버는 도커 외부에서 다중 호스트 네트워크를 지원하는 오버레이 네트워크를 생성함. 로컬 리눅스 브리지와 VXLAN을 함께 사용하여 물리적 네트워크 인프라를 통해 컨테이너와 컨테이너 간의 통신을 오버레이함. |
| MACVLAN  | `macvlan` 드라이버는 MACVLAN 브리지 모드를 사용해서 컨테이너 인터페이스와 상위 호스트 인터페이스(또는 하위 인터페이스) 간의 연결을 설정함. 물리적 네트워크에서 라우팅 가능한 컨테이너에 IP 주소를 제공하기 위해 사용될 수 있음. 또한 VLAN은 레이어 2 컨테이너 분할을 실행하기 위해 macvlan 드라이버에 트렁킹될 수 있음. |
| None     | `none` 드라이버는 컨테이너에 자체 네트워킹 스택과 네트워크 네임스페이스를 제공하지만, 컨테이너 내부에 인터페이스를 구성하지는 않음. 추가 구성없이 컨테이너가 호스트 네트워킹 스택에서 완전히 분리됨. |

## 네트워크 스코프

`docker network ls` 출력에서 볼 수 있듯이, 도커 네트워크 드라이버는 *스코프* 라는 개념이 있다. 네트워크 스코프는 `local` 또는 `swarm` 범위인 드라이버의 도메인이다. Local 스코프 드라이버는 호스트의 범위 내에서 연결 및 네트워크 서비스(예: DNS 또는 IPAM)를 제공한다. Swarm 스코프 드라이버는 Swarm 클러스터 전반에서 연결 및 네트워크 서비스를 제공한다. Swarm 스코프 네트워크는 전체 클러스터에서 동일한 네트워크 ID를 가지고 있고, 반면에 Local 스코프 네트워크는 각 호스트에 고유한 네트워크 ID를 가지고 있다.

```
$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
1475f03fbecb        bridge              bridge              local
e2d8a4bd86cb        docker_gwbridge     bridge              local
407c477060e7        host                host                local
f4zr3zrswlyg        ingress             overlay             swarm
c97909a4b198        none                null                local
```

## 도커 원격 네트워크 드라이버
아래 커뮤니티 및 벤더에서 만든 원격 네트워크 드라이버는 CNM과 호환되며, 각 드라이버는 컨테이너를 위한 고유한 기능과 네트워크 서비스를 제공한다.

|드라이버 | 설명 |
|----------------------------------|----------|
|[contiv](http://contiv.github.io/)<img width=250/>| 멀티 테넌트 (Multi-tenant) 마이크로 서비스 구현를 위한 인프라 및 보안 정책을 제공하는 오픈 소스 네트워크 플러그인, Cisco Systems가 리딩. 또한 Contiv는 비컨테이너 워크로드 및 ACI와 같은 물리적 네트워크에 대해 통합됨. Contiv는 원격 네트워크 및 IPAM 드라이버를 구현하고 있음.|
|[weave](https://www.weave.works/docs/net/latest/introducing-weave/)|도커 컨테이너를 여러 호스트 또는 클라우드에 연결하는 가상 네트워크를 만드는 네트워크 플러그인. Weave는 애플리케이션 자동 검색 기능을 제공하며 부분적으로 연결된 네트워크에서 작동할 수 있으며, 외부 클러스터 저장소가 필요하지 않고, 운영 친화적임.|
|[calico](https://www.projectcalico.org/)| 클라우드 데이터 센터의 가상 네트워킹을 위한 오픈 소스 솔루션. 대부분의 워크로드(VM, 컨테이너 또는 베어 메탈 서버)가 IP 연결만 필요로 하는 데이터 센터를 대상으로 함. Calico는 표준 IP 라우팅을 사용하여 이 연결성을 제공함. 테넌트 소유권 또는보다 세분화된 정책에 따라 워크로드 간의 격리는 소스 및 대상 워크로드를 호스팅하는 서버에서 iptables 프로그래밍을 통해 수행됨.|
|[kuryr](https://github.com/openstack/kuryr)|OpenStack Kuryr 프로젝트의 일부로 개발된 네트워크 플러그인. OpenStack 네트워킹 서비스인 Neutron을 활용하여 Docker 네트워킹 (libnetwork) 원격 드라이버 API를 구현함. Kuryr에는 IPAM 드라이버도 포함되어 있음.|

## 도커 원격 IPAM 드라이버

커뮤니티 및 벤더가 생성한 IPAM 드라이버도 기존 시스템 또는 특수 기능과의 통합을 제공하는데 사용될 수 있다.

| 드라이버 | 설명 |
|--------|------|
|[infobox](https://hub.docker.com/r/infoblox/ipam-driver/)| 기존 Infoblox 툴과 통합되는 오픈소스 IPAM 플러그인. |

	많은 도커 플러그인이 존재하며, 더 많은 플러그인이 항상 생성되고 있다. 도커는 가장 일반적인 플러그인 목록을 유지한다.

# 리눅스 네트워크 원리

리눅스 커널은 TCP/IP 스택 (DNS 및 VXLAN과 같은 기타 네이티브 커널 기능과 더불어)을 매우 성숙하고 효율적으로 구현한다. 도커 네트워킹은 커널의 네트워킹 스택을 하위 레벨의 기본 요소로 사용하여 상위 레벨의 네트워크 드라이버를 만든다. 간단히 말해서, 도커 네트워킹은 리눅스 네트워킹이다.

기존에 구현된 리눅스 커널 기능은 고성능과 견고성을 보장한다. 가장 중요한 점은 여러 배포판과 버전에 걸쳐 이식성을 제공하므로 애플리케이션의 이식성이 향샹된다는 것이다.

도커가 네이티브 CNM 네트워크 드라이버를 구현하는데 사용하는 몇 가지 리눅스 네트워킹 빌딩 블록이 있다. 이 목록에는 리눅스 브리지, 네트워크 네임스페이스, veth pair 및 iptable이 포함된다. 네트워크 드라이버로 구현되는 이러한 도구의 조합은 복잡한 네트워크 정책을 위한 전달 규칙, 네트워크 분할 및 관리 도구를 제공한다.

## 리눅스 브리지

리눅스 브리지는 리눅스 커널 내부의 물리적 스위치를 가상으로 구현한 Layer 2 디바이스이다. 트래픽을 검사하여 동적으로 학습되는 MAC 주소를 기반으로 트래픽을 전달한다. 리눅스 브리지는 많은 도커 네트워크 드라이버에서 광범위하게 사용된다. 리눅스 브리지는 리눅스 브리지의 상위 레벨 구현인 브리지 도커 네트워크 드라이버와 혼동되어서는 안된다.

## 네트워크 네임스페이스

리눅스 네트워크 네임스페이스는 커널에 격리된 네트워크 스택으로 자체 인터페이스, 라우트 및 방화벽 규칙을 지니고 있다. 컨테이너와 리눅스의 보안적인 특징으로, 컨테이너를 분리하는데 사용된다. 네트워킹 용어에서는 호스트 내부의 네트워크 제어와 데이터 플레인을 격리하는 VRF와 유사하다. 네트워크 네임 스페이스는 도커 네트워크를 통해 구성된 경우가 아니면 동일한 호스트의 두 컨테이너가 서로 통신하거나 호스트 자체와 통신할 수 없음을 보장한다. 일반적으로 CNM 네트워크 드라이버는 각 컨테이너에 대해 별도의 네임스페이스를 구현한다. 그러나 컨테이너는 동일한 네트워크 네임스페이스를 공유할 수도 있고 호스트의 네트워크 네임스페이스의 일부가 될 수도 있다. 호스트 네트워크 네임스페이스 컨테이너는 호스트 인터페이스와 호스트 라우팅 테이블이다. 이 네트워크 네임스페이스를 글로벌 네트워크 네임스페이스라고 한다.

## 가상 이더넷 디바이스

**가상 이더넷 디바이스 (virtual ethernet device)** 또는 **veth**는 두 네트워크 네임스페이스 사이의 연결선으로 동작하는 리눅스 네트워킹 인터페이스이다. veth는 각 네임스페이스에 단일 인터페이스가 있는 전이중 링크(full duplex link)이다. 한 인터페이스의 트래픽은 다른 인터페이스로 전달된다. 도커 네트워크를 만들 때 도커 네트워크 드라이버는 veth를 사용하여 네임스페이스간에 명시적인 연결을 제공한다. 컨테이너가 도커 네트워크에 연결되면 veth의 한쪽 끝은 컨테이너 내부에 배치되며 (일반적으로 `ethX` 인터페이스로 표시됨), 다른 쪽은 도커 네트워크에 연결된다.

## iptables

`iptables`는 네이티브 패킷 필터링 시스템으로 버전 2.4 이후 리눅스 커널의 일부였다. 이는 패킷 마킹, 매스쿼레이딩(masquerading) 및 드라핑(dropping)에 대한 룰체인을 제공하는 기능이 풍부한 L3/L4 방화벽이다. 네이티브 도커 네트워크 드라이버는 iptables를 광범위하게 활용하여 네트워크 트래픽을 세분화하고, 호스트 포트 매핑을 제공하며, 로드밸런싱 결정을 위해 트래픽을 마킹한다. 

# Docker Network Control Plane

# Docker Host Network Driver

# Docker Bridge Network Driver

## Default Docker Bridge Network

## User-Defined Bridge Networks

## External Access for Standalone Containers

# Overlay Driver Network Architecture

## VXLAN Data Plane
## Overlay Driver Internal Architecture

# External Access for Docker Services

## Ingress Mode Service Publishing
## Host Mode Service Publishing
## Ingress Design
# MACVLAN
## VLAN Trunking with MACVLAN

# None (Isolated) Network Driver

# Physical Network Design Requirements

# Swarm Native Service Discovery

# Docker Native Load Balancing

## UCP Internal Load Balancing

## UCP External L4 Load Balancing (Docker Routing Mesh)

## UCP External L7 Load Balancing (HTTP Routing Mesh)

# Docker Network Security and Encryption

## Network Segmentation and Data Plane Security

## Control Plane Security
## Data Plane Network Encryption
## Management Plane Security & RBAC with UCP

# IP Address Management

# Network Troubleshooting

# Network Deployment Models

## Bridge Driver on a Single Host
## Multi-Host Bridge Driver with External Service Discovery
## Multi-Host with Overlay Driver
### Overlay Benefits and Use Cases

## Tutorial App: MACVLAN Bridge Mode

### MACVLAN Benefits and Use Cases

# Conclusion







